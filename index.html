<div class="feature-card">
                    <h3>üß† AI Nh·∫≠n Di·ªán Si√™u Th√¥ng Minh</h3>
                                <div class="advanced-options">
                <h4>‚öôÔ∏è T√πy ch·ªçn n√¢ng cao</h4>
                <div class="option-group">
                    <div class="option-item">
                        <input type="checkbox" id="removeVietnameseTones" checked>
                        <label for="removeVietnameseTones">X·ª≠ l√Ω d·∫•u ti·∫øng Vi·ªát (ch·ªâ d√πng cho logic n·ªôi b·ªô)</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="normalizeDate" checked>
                        <label for="normalizeDate">Chu·∫©n h√≥a ng√†y sinh (YYYYMMDD ‚Üí DD/MM/YYYY)</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="mergeNameFields" checked>
                        <label for="mergeNameFields">T·ª± ƒë·ªông gh√©p h·ªç + t√™n</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="mergeAddressFields" checked>
                        <label for="mergeAddressFields">T·ª± ƒë·ªông gh√©p th√†nh ƒë·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="requirePhoneNumber" checked>
                        <label for="requirePhoneNumber">Ch·ªâ gi·ªØ d√≤ng c√≥ s·ªë ƒëi·ªán tho·∫°i h·ª£p l·ªá</label>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: #e8f5e8; border-radius: 8px; font-size: 14px;">
                    <strong>üí° L∆∞u √Ω:</strong> File xu·∫•t ra s·∫Ω hi·ªÉn th·ªã <strong>ti·∫øng Vi·ªát c√≥ d·∫•u ƒë·∫ßy ƒë·ªß</strong> 
                    (Nguy·ªÖn VƒÉn An, H√† N·ªôi, C√¥ng gi√°o...) ƒë·ªÉ d·ªÖ ƒë·ªçc v√† in ·∫•n.
                </div>
            </div><!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Excel Data Processor Pro - N√¢ng cao To√†n Di·ªán</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.3em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .upload-zone {
            border: 3px dashed #4A90E2;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: #ecf0f1;
            position: relative;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .upload-zone:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-zone.dragover {
            border-color: #667eea;
            background: #e3f2fd;
            transform: scale(1.02);
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin: 0 10px;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .multiple-files-info {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .file-item .name {
            font-weight: 500;
            flex: 1;
            margin-right: 10px;
        }

        .file-item .size {
            color: #666;
            font-size: 0.9em;
            margin-right: 10px;
        }

        .file-item .remove {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 12px;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature-card {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
        }

        .feature-card h3 {
            font-size: 1.4em;
            margin-bottom: 15px;
        }

        .feature-card ul {
            list-style: none;
            text-align: left;
        }

        .feature-card li {
            margin: 10px 0;
            padding-left: 25px;
            position: relative;
            font-size: 0.95em;
        }

        .feature-card li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            font-weight: bold;
            color: #00ff88;
        }

        .progress-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            display: none;
        }

        .progress-section.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .processing-files {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .file-progress {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }

        .file-progress .name {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .file-progress .status {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .file-progress .mini-progress {
            width: 100%;
            height: 6px;
            background: #f0f0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .file-progress .mini-fill {
            height: 100%;
            background: #4caf50;
            width: 0%;
            transition: width 0.3s ease;
        }

        .analysis-results {
            display: none;
            margin-top: 30px;
        }

        .analysis-results.show {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-weight: 500;
        }

        .data-preview {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .data-preview-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-container {
            max-height: 500px;
            overflow: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        th, td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894, #00a085);
        }

        .btn-warning {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4757, #ff3742);
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }

        .status-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .status-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .data-validation {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .validation-item {
            margin: 8px 0;
            padding: 5px 0;
        }

        .validation-pass {
            color: #155724;
        }

        .validation-warning {
            color: #856404;
        }

        .validation-error {
            color: #721c24;
        }

        .advanced-options {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #e0e0e0;
        }

        .advanced-options h4 {
            margin-bottom: 15px;
            color: #333;
        }

        .option-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-item label {
            font-weight: 500;
            cursor: pointer;
        }

        .option-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .features-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .action-buttons {
                flex-direction: column;
                align-items: center;
            }

            .processing-files {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ AI Excel Data Processor Pro</h1>
            <p>X·ª≠ l√Ω th√¥ng minh, kh√¥ng gi·ªõi h·∫°n - H·ªó tr·ª£ ƒëa file, chu·∫©n h√≥a to√†n di·ªán</p>
        </div>

        <div class="main-content">
            <div class="upload-zone" id="uploadZone">
                <h3>üìÅ T·∫£i l√™n file Excel (H·ªó tr·ª£ ƒëa file)</h3>
                <p>K√©o th·∫£ nhi·ªÅu file ho·∫∑c click ƒë·ªÉ ch·ªçn (.xlsx, .xlsm, .xls)</p>
                <p><strong>‚ú® Kh√¥ng gi·ªõi h·∫°n s·ªë file, d√≤ng, c·ªôt, sheet ‚ú®</strong></p>
                <br>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    üìÇ Ch·ªçn file Excel
                </button>
                <button class="upload-btn" onclick="clearAllFiles()" style="background: linear-gradient(135deg, #ff4757, #ff3742);">
                    üóëÔ∏è X√≥a t·∫•t c·∫£
                </button>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xlsm,.xls" multiple onchange="handleFileUpload(event)">
                
                <div id="fileList" class="multiple-files-info" style="display: none;">
                    <h4>üìã Danh s√°ch file ƒë√£ ch·ªçn:</h4>
                    <div class="file-list" id="selectedFiles"></div>
                    <p><strong>T·ªïng c·ªông: <span id="totalFiles">0</span> file</strong></p>
                </div>
            </div>

            <div class="advanced-options">
                <h4>‚öôÔ∏è T√πy ch·ªçn n√¢ng cao</h4>
                <div class="option-group">
                    <div class="option-item">
                        <input type="checkbox" id="removeVietnameseTones" checked>
                        <label for="removeVietnameseTones">Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="normalizeDate" checked>
                        <label for="normalizeDate">Chu·∫©n h√≥a ng√†y sinh (YYYYMMDD)</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="mergeNameFields" checked>
                        <label for="mergeNameFields">Gh√©p h·ªç + t√™n</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="mergeAddressFields" checked>
                        <label for="mergeAddressFields">Gh√©p th√†nh ƒë·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="requirePhoneNumber" checked>
                        <label for="requirePhoneNumber">Ch·ªâ gi·ªØ d√≤ng c√≥ s·ªë ƒëi·ªán tho·∫°i</label>
                    </div>
                </div>
            </div>

            <div class="features-grid">
                <div class="feature-card">
                    <h3>üß† AI Nh·∫≠n Di·ªán Si√™u Th√¥ng Minh</h3>
                    <ul>
                        <li>Nh·∫≠n di·ªán header ti·∫øng Vi·ªát + vi·∫øt t·∫Øt</li>
                        <li>Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát t·ª± ƒë·ªông</li>
                        <li>Chu·∫©n h√≥a ng√†y sinh ƒëa format</li>
                        <li>Gh√©p h·ªç + t√™n th√†nh "H·ªç v√† t√™n"</li>
                        <li>T·ª± ƒë·ªông th√™m s·ªë 0 cho SƒêT</li>
                    </ul>
                </div>
                <div class="feature-card">
                    <h3>üîÑ X·ª≠ L√Ω Kh√¥ng Gi·ªõi H·∫°n</h3>
                    <ul>
                        <li>X·ª≠ l√Ω nhi·ªÅu file Excel c√πng l√∫c</li>
                        <li>Kh√¥ng gi·ªõi h·∫°n d√≤ng, c·ªôt, sheet</li>
                        <li>Qu√©t to√†n b·ªô sheet trong t·∫•t c·∫£ file</li>
                        <li>T·ª± ƒë·ªông lo·∫°i b·ªè d√≤ng tr·ªëng</li>
                        <li>Gh√©p ƒë·ªãa ch·ªâ t·ª´ nhi·ªÅu c·ªôt</li>
                    </ul>
                </div>
                <div class="feature-card">
                    <h3>‚úÖ L·ªçc & Ki·ªÉm Tra N√¢ng Cao</h3>
                    <ul>
                        <li>Ch·ªâ gi·ªØ d√≤ng c√≥ s·ªë ƒëi·ªán tho·∫°i</li>
                        <li>Validate SƒêT Vi·ªát Nam chu·∫©n</li>
                        <li>Ki·ªÉm tra ng√†y sinh logic</li>
                        <li>B√°o c√°o chi ti·∫øt t·ª´ng file</li>
                        <li>Preview to√†n di·ªán tr∆∞·ªõc xu·∫•t</li>
                    </ul>
                </div>
            </div>

            <div class="action-buttons" style="margin: 20px 0;">
                <button class="btn btn-success" onclick="processAllFiles()" id="processBtn" disabled>
                    üöÄ X·ª≠ l√Ω t·∫•t c·∫£ file
                </button>
            </div>

            <div class="progress-section" id="progressSection">
                <h4>üîÑ ƒêang x·ª≠ l√Ω...</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p id="progressText">ƒêang kh·ªüi t·∫°o...</p>
                
                <div class="processing-files" id="processingFiles">
                    <!-- File progress items s·∫Ω ƒë∆∞·ª£c ƒëi·ªÅn b·∫±ng JavaScript -->
                </div>
            </div>

            <div id="statusMessage"></div>

            <div class="analysis-results" id="analysisResults">
                <h3>üìä K·∫øt qu·∫£ x·ª≠ l√Ω to√†n di·ªán</h3>
                
                <div class="stats-grid" id="statsGrid">
                    <!-- Stats s·∫Ω ƒë∆∞·ª£c ƒëi·ªÅn b·∫±ng JavaScript -->
                </div>

                <div class="data-validation" id="dataValidation">
                    <h4>üîç Ki·ªÉm tra d·ªØ li·ªáu</h4>
                    <div id="validationResults">
                        <!-- Validation results s·∫Ω ƒë∆∞·ª£c ƒëi·ªÅn b·∫±ng JavaScript -->
                    </div>
                </div>

                <div class="data-preview" id="dataPreview">
                    <div class="data-preview-header">
                        <span>üìã Xem tr∆∞·ªõc d·ªØ li·ªáu ƒë√£ chu·∫©n h√≥a</span>
                        <span id="previewCount"></span>
                    </div>
                    <div class="table-container">
                        <table id="previewTable">
                            <thead id="tableHeader"></thead>
                            <tbody id="tableBody"></tbody>
                        </table>
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-success" onclick="downloadProcessedFile()" id="downloadBtn" disabled>
                        üì• T·∫£i xu·ªëng Excel ƒë√£ chu·∫©n h√≥a
                    </button>
                    <button class="btn btn-warning" onclick="downloadReport()" id="reportBtn" disabled>
                        üìä T·∫£i b√°o c√°o chi ti·∫øt
                    </button>
                    <button class="btn" onclick="resetProcessor()">
                        üîÑ X·ª≠ l√Ω file m·ªõi
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedFiles = [];
        let processedData = [];
        let originalData = [];
        let processingStats = {};
        let validationResults = {};
        let fileProgress = {};

        // Kh·ªüi t·∫°o drag & drop cho nhi·ªÅu file
        const uploadZone = document.getElementById('uploadZone');
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            addFiles(files);
        });

        function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            addFiles(files);
        }

        function addFiles(files) {
            const validFiles = files.filter(file => {
                const validTypes = ['.xlsx', '.xlsm', '.xls'];
                const fileName = file.name.toLowerCase();
                return validTypes.some(type => fileName.endsWith(type));
            });

            if (validFiles.length !== files.length) {
                showWarning(`M·ªôt s·ªë file kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Ch·ªâ ch·∫•p nh·∫≠n file Excel (.xlsx, .xlsm, .xls)`);
            }

            validFiles.forEach(file => {
                const isDuplicate = selectedFiles.some(f => f.name === file.name && f.size === file.size);
                if (!isDuplicate) {
                    selectedFiles.push(file);
                }
            });

            updateFileList();
        }

        function updateFileList() {
            const fileListDiv = document.getElementById('fileList');
            const selectedFilesDiv = document.getElementById('selectedFiles');
            const totalFilesSpan = document.getElementById('totalFiles');
            const processBtn = document.getElementById('processBtn');

            if (selectedFiles.length === 0) {
                fileListDiv.style.display = 'none';
                processBtn.disabled = true;
                return;
            }

            fileListDiv.style.display = 'block';
            processBtn.disabled = false;
            
            selectedFilesDiv.innerHTML = '';
            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <span class="name">${file.name}</span>
                    <span class="size">${formatFileSize(file.size)}</span>
                    <button class="remove" onclick="removeFile(${index})" title="X√≥a file">√ó</button>
                `;
                selectedFilesDiv.appendChild(fileItem);
            });

            totalFilesSpan.textContent = selectedFiles.length;
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateFileList();
        }

        function clearAllFiles() {
            selectedFiles = [];
            updateFileList();
            document.getElementById('fileInput').value = '';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        async function processAllFiles() {
            if (selectedFiles.length === 0) {
                showError('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt file Excel ƒë·ªÉ x·ª≠ l√Ω');
                return;
            }

            showProgress(true);
            processedData = [];
            fileProgress = {};
            
            // Kh·ªüi t·∫°o progress cho t·ª´ng file
            initFileProgress();
            
            updateProgress(0, `ƒêang x·ª≠ l√Ω ${selectedFiles.length} file...`);
            
            try {
                let totalProcessed = 0;
                let globalStats = {
                    totalFiles: selectedFiles.length,
                    totalSheets: 0,
                    totalRecords: 0,
                    validRecords: 0,
                    filesWithData: 0
                };

                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    const fileProgressPercent = (i / selectedFiles.length) * 100;
                    
                    updateProgress(fileProgressPercent, `ƒêang x·ª≠ l√Ω file: ${file.name}`);
                    updateFileProgress(file.name, 0, 'ƒêang ƒë·ªçc file...');
                    
                    try {
                        // ƒê·ªçc file
                        const arrayBuffer = await file.arrayBuffer();
                        updateFileProgress(file.name, 20, 'Ph√¢n t√≠ch c·∫•u tr√∫c...');
                        
                        const workbook = XLSX.read(arrayBuffer, {
                            cellStyles: true,
                            cellFormulas: true,
                            cellDates: true,
                            cellNF: true,
                            sheetStubs: true
                        });

                        updateFileProgress(file.name, 40, 'Tr√≠ch xu·∫•t d·ªØ li·ªáu...');
                        
                        // Ph√¢n t√≠ch t·∫•t c·∫£ sheet
                        const allSheetData = await analyzeAllSheets(workbook, file.name);
                        globalStats.totalSheets += Object.keys(allSheetData).length;
                        
                        updateFileProgress(file.name, 60, 'Chu·∫©n h√≥a d·ªØ li·ªáu...');
                        
                        // X·ª≠ l√Ω v√† chu·∫©n h√≥a d·ªØ li·ªáu
                        const fileProcessedData = await processAndStandardizeData(allSheetData, file.name);
                        
                        if (fileProcessedData.length > 0) {
                            globalStats.filesWithData++;
                            globalStats.totalRecords += fileProcessedData.length;
                            processedData.push(...fileProcessedData);
                        }
                        
                        updateFileProgress(file.name, 100, `Ho√†n th√†nh (${fileProcessedData.length} b·∫£n ghi)`);
                        
                    } catch (fileError) {
                        updateFileProgress(file.name, 100, `L·ªói: ${fileError.message}`);
                        console.error(`L·ªói x·ª≠ l√Ω file ${file.name}:`, fileError);
                    }
                }
                
                updateProgress(90, 'Ki·ªÉm tra ch·∫•t l∆∞·ª£ng d·ªØ li·ªáu...');
                
                // Validate to√†n b·ªô d·ªØ li·ªáu
                validationResults = validateData(processedData);
                globalStats.validRecords = validationResults.totalRecords;
                processingStats = globalStats;
                
                updateProgress(100, 'Ho√†n th√†nh t·∫•t c·∫£!');
                
                // Hi·ªÉn th·ªã k·∫øt qu·∫£
                displayResults(processedData);
                
                setTimeout(() => showProgress(false), 1000);
                
            } catch (error) {
                showError(`L·ªói x·ª≠ l√Ω: ${error.message}`);
                showProgress(false);
            }
        }

        function initFileProgress() {
            const processingFilesDiv = document.getElementById('processingFiles');
            processingFilesDiv.innerHTML = '';
            
            selectedFiles.forEach(file => {
                const progressItem = document.createElement('div');
                progressItem.className = 'file-progress';
                progressItem.id = `progress-${file.name}`;
                progressItem.innerHTML = `
                    <div class="name">${file.name}</div>
                    <div class="status">Ch·ªù x·ª≠ l√Ω...</div>
                    <div class="mini-progress">
                        <div class="mini-fill"></div>
                    </div>
                `;
                processingFilesDiv.appendChild(progressItem);
            });
        }

        function updateFileProgress(fileName, percent, status) {
            const progressItem = document.getElementById(`progress-${fileName}`);
            if (progressItem) {
                const statusDiv = progressItem.querySelector('.status');
                const fillDiv = progressItem.querySelector('.mini-fill');
                
                statusDiv.textContent = status;
                fillDiv.style.width = percent + '%';
                
                if (percent === 100 && !status.includes('L·ªói')) {
                    fillDiv.style.background = '#4caf50';
                } else if (status.includes('L·ªói')) {
                    fillDiv.style.background = '#ff4757';
                }
            }
        }

        // H√†m lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát
        function removeVietnameseTones(str) {
            if (!str) return '';
            
            const toneMap = {
                '√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ': 'a',
                '√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ': 'e',
                '√¨√≠·ªã·ªâƒ©': 'i',
                '√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°': 'o',
                '√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ': 'u',
                '·ª≥√Ω·ªµ·ª∑·ªπ': 'y',
                'ƒë': 'd',
                '√Ä√Å·∫†·∫¢√É√Ç·∫¶·∫§·∫¨·∫®·∫™ƒÇ·∫∞·∫Æ·∫∂·∫≤·∫¥': 'A',
                '√à√â·∫∏·∫∫·∫º√ä·ªÄ·∫æ·ªÜ·ªÇ·ªÑ': 'E',
                '√å√ç·ªä·ªàƒ®': 'I',
                '√í√ì·ªå·ªé√ï√î·ªí·ªê·ªò·ªî·ªñ∆†·ªú·ªö·ª¢·ªû·ª†': 'O',
                '√ô√ö·ª§·ª¶≈®∆Ø·ª™·ª®·ª∞·ª¨·ªÆ': 'U',
                '·ª≤√ù·ª¥·ª∂·ª∏': 'Y',
                'ƒê': 'D'
            };
            
            let result = str;
            for (const [accented, plain] of Object.entries(toneMap)) {
                for (const char of accented) {
                    result = result.replace(new RegExp(char, 'g'), plain);
                }
            }
            
            return result;
        }

        // H√†m chu·∫©n h√≥a ng√†y sinh n√¢ng cao
        function normalizeBirthDate(dateStr) {
            if (!dateStr) return '';
            
            const cleaned = dateStr.toString().replace(/[^\d\/\-\.]/g, '');
            
            // Format YYYYMMDD (8 ch·ªØ s·ªë li·ªÅn nhau)
            if (/^\d{8}$/.test(cleaned)) {
                const year = cleaned.substring(0, 4);
                const month = cleaned.substring(4, 6);
                const day = cleaned.substring(6, 8);
                
                if (isValidDate(day, month, year)) {
                    return `${day}/${month}/${year}`;
                }
            }
            
            // Format DD/MM/YYYY ho·∫∑c DD-MM-YYYY ho·∫∑c DD.MM.YYYY
            const datePatterns = [
                /^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/,
                /^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/
            ];
            
            for (const pattern of datePatterns) {
                const match = cleaned.match(pattern);
                if (match) {
                    let day, month, year;
                    
                    if (match[3].length === 4) { // DD/MM/YYYY
                        day = match[1].padStart(2, '0');
                        month = match[2].padStart(2, '0');
                        year = match[3];
                    } else { // YYYY/MM/DD
                        year = match[1];
                        month = match[2].padStart(2, '0');
                        day = match[3].padStart(2, '0');
                    }
                    
                    if (isValidDate(day, month, year)) {
                        return `${day}/${month}/${year}`;
                    }
                }
            }
            
            return cleaned; // Tr·∫£ v·ªÅ nguy√™n b·∫£n n·∫øu kh√¥ng chu·∫©n h√≥a ƒë∆∞·ª£c
        }

        function isValidDate(day, month, year) {
            const d = parseInt(day);
            const m = parseInt(month);
            const y = parseInt(year);
            
            if (y < 1900 || y > 2024) return false;
            if (m < 1 || m > 12) return false;
            if (d < 1 || d > 31) return false;
            
            // Ki·ªÉm tra ng√†y h·ª£p l·ªá theo th√°ng
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            
            // NƒÉm nhu·∫≠n
            if (m === 2 && ((y % 4 === 0 && y % 100 !== 0) || (y % 400 === 0))) {
                return d <= 29;
            }
            
            return d <= daysInMonth[m - 1];
        }

        // Nh·∫≠n di·ªán header th√¥ng minh h∆°n v·ªõi vi·∫øt t·∫Øt
        function isHeaderLikeCell(cell) {
            if (!cell || typeof cell !== 'string') return false;
            
            const headerKeywords = [
                // Ti·∫øng Vi·ªát ƒë·∫ßy ƒë·ªß
                'h·ªç', 't√™n', 'ng√†y', 'th√°ng', 'nƒÉm', 'sinh', 'ƒë·ªãa ch·ªâ', 'ƒëi·ªán tho·∫°i', 
                'd√¢n t·ªôc', 't√¥n gi√°o', 'gi·ªõi t√≠nh', 's·ªë nh√†', 'ƒë∆∞·ªùng', 'ph∆∞·ªùng', 'qu·∫≠n',
                'huy·ªán', 'th√†nh ph·ªë', 't·ªânh', 'khu ph·ªë', 'mobile', 'phone', 'email',
                
                // Vi·∫øt t·∫Øt
                'stt', 'sƒët', 'ƒët', 'ns', 'gt', 'dc', 'tp', 'hn', 'hcm',
                'p.', 'q.', 'h.', 'tt.', 'kp', 'tdp',
                
                // Ti·∫øng Anh
                'name', 'first', 'last', 'birth', 'date', 'address', 'phone', 'mobile',
                'street', 'ward', 'district', 'city', 'province'
            ];
            
            const cellLower = cell.toLowerCase().trim();
            return headerKeywords.some(keyword => cellLower.includes(keyword));
        }

        async function analyzeAllSheets(workbook, fileName) {
            const sheetsData = {};
            
            workbook.SheetNames.forEach(sheetName => {
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                
                // Lo·∫°i b·ªè d√≤ng tr·ªëng t·ª´ ƒë·∫ßu
                const cleanedData = removeEmptyRowsFromStart(jsonData);
                
                sheetsData[sheetName] = {
                    name: sheetName,
                    fileName: fileName,
                    data: cleanedData,
                    rowCount: cleanedData.length,
                    colCount: cleanedData[0] ? cleanedData[0].length : 0,
                    hasData: cleanedData.some(row => hasValidRowData(row))
                };
            });
            
            return sheetsData;
        }

        function removeEmptyRowsFromStart(data) {
            const cleaned = [];
            let foundData = false;
            
            for (const row of data) {
                if (!foundData && hasValidRowData(row)) {
                    foundData = true;
                }
                
                if (foundData) {
                    cleaned.push(row);
                }
            }
            
            return cleaned;
        }

        function hasValidRowData(row) {
            if (!row || row.length === 0) return false;
            
            return row.some(cell => {
                const cellStr = cell ? cell.toString().trim() : '';
                return cellStr && 
                       cellStr !== '' && 
                       !cellStr.toLowerCase().includes('th√¥ng b√°o l·ªói') &&
                       !cellStr.toLowerCase().includes('error');
            });
        }

        function detectHeaderRow(data) {
            for (let i = 0; i < Math.min(15, data.length); i++) {
                const row = data[i];
                if (row && row.length > 0) {
                    // Ki·ªÉm tra s·ªë l∆∞·ª£ng cell c√≥ keywords header
                    const headerLikeCells = row.filter(cell => isHeaderLikeCell(cell));
                    
                    // N·∫øu c√≥ √≠t nh·∫•t 30% cell l√† header-like ho·∫∑c √≠t nh·∫•t 2 cell
                    if (headerLikeCells.length >= Math.max(2, row.length * 0.3)) {
                        return i;
                    }
                }
            }
            
            // Fallback: t√¨m d√≤ng ƒë·∫ßu ti√™n c√≥ d·ªØ li·ªáu
            for (let i = 0; i < Math.min(5, data.length); i++) {
                if (hasValidRowData(data[i])) {
                    return i;
                }
            }
            
            return 0;
        }

        async function processAndStandardizeData(sheetsData, fileName) {
            const allProcessedData = [];
            const options = getProcessingOptions();
            
            for (const [sheetName, sheetInfo] of Object.entries(sheetsData)) {
                if (!sheetInfo.hasData) continue;
                
                // Ph√°t hi·ªán header t·ª± ƒë·ªông
                const headerRow = detectHeaderRow(sheetInfo.data);
                const headers = sheetInfo.data[headerRow] || [];
                
                // X·ª≠ l√Ω t·ª´ng h√†ng d·ªØ li·ªáu
                for (let i = headerRow + 1; i < sheetInfo.data.length; i++) {
                    const row = sheetInfo.data[i];
                    
                    // Ki·ªÉm tra h√†ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá kh√¥ng
                    if (!hasValidRowData(row)) continue;
                    
                    // Chu·∫©n h√≥a d·ªØ li·ªáu
                    const standardizedRow = standardizeRowData(row, headers, sheetName, fileName, options);
                    
                    if (standardizedRow) {
                        // Ki·ªÉm tra ƒëi·ªÅu ki·ªán b·∫Øt bu·ªôc c√≥ s·ªë ƒëi·ªán tho·∫°i
                        if (options.requirePhoneNumber) {
                            if (!standardizedRow['ƒêi·ªán tho·∫°i'] || !isValidPhoneNumber(standardizedRow['ƒêi·ªán tho·∫°i'])) {
                                continue; // B·ªè qua d√≤ng kh√¥ng c√≥ SƒêT h·ª£p l·ªá
                            }
                        }
                        
                        allProcessedData.push(standardizedRow);
                    }
                }
            }
            
            return allProcessedData;
        }

        function getProcessingOptions() {
            return {
                removeVietnameseTones: document.getElementById('removeVietnameseTones').checked,
                normalizeDate: document.getElementById('normalizeDate').checked,
                mergeNameFields: document.getElementById('mergeNameFields').checked,
                mergeAddressFields: document.getElementById('mergeAddressFields').checked,
                requirePhoneNumber: document.getElementById('requirePhoneNumber').checked
            };
        }

        function standardizeRowData(row, headers, sheetName, fileName, options) {
            const standardized = {
                STT: processedData.length + 1,
                SheetSource: `${fileName} - ${sheetName}`
            };
            
            // Map d·ªØ li·ªáu theo header - GI·ªÆ NGUY√äN d·ªØ li·ªáu g·ªëc c√≥ d·∫•u
            const rawDataOriginal = {}; // D·ªØ li·ªáu g·ªëc c√≥ d·∫•u
            const rawDataNormalized = {}; // D·ªØ li·ªáu kh√¥ng d·∫•u (ch·ªâ d√πng cho x·ª≠ l√Ω logic)
            
            headers.forEach((header, index) => {
                if (header && row[index] !== undefined) {
                    let cellValue = row[index] ? row[index].toString().trim() : '';
                    
                    const normalizedHeader = normalizeHeader(header);
                    
                    // L∆∞u d·ªØ li·ªáu g·ªëc c√≥ d·∫•u
                    rawDataOriginal[normalizedHeader] = cellValue;
                    
                    // T·∫°o phi√™n b·∫£n kh√¥ng d·∫•u CH·ªà cho x·ª≠ l√Ω logic (kh√¥ng xu·∫•t ra)
                    let normalizedValue = cellValue;
                    if (options.removeVietnameseTones && cellValue) {
                        normalizedValue = removeVietnameseTones(cellValue);
                        rawDataNormalized[normalizedHeader] = normalizedValue;
                    } else {
                        rawDataNormalized[normalizedHeader] = cellValue;
                    }
                    
                    // Th√™m v√†o standardized (GI·ªÆ NGUY√äN c√≥ d·∫•u)
                    standardized[normalizedHeader] = cellValue;
                }
            });
            
            // X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho c√°c tr∆∞·ªùng quan tr·ªçng - CH·ªà XU·∫§T D·ªÆ LI·ªÜU C√ì D·∫§U
            
            // 1. Gh√©p h·ªç + t√™n - GI·ªÆ D·∫§U trong output
            if (options.mergeNameFields) {
                const originalName = extractAndMergeFullName(rawDataOriginal, row);
                standardized['H·ªç v√† t√™n'] = originalName; // CH·ªà hi·ªÉn th·ªã c√≥ d·∫•u
            }
            
            // 2. Chu·∫©n h√≥a ng√†y sinh
            if (options.normalizeDate) {
                standardized['Ng√†y sinh'] = extractAndNormalizeBirthDate(rawDataOriginal, row);
            }
            
            // 3. Gh√©p ƒë·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß - GI·ªÆ D·∫§U trong output
            if (options.mergeAddressFields) {
                const originalAddress = extractAndMergeAddress(rawDataOriginal);
                standardized['ƒê·ªãa ch·ªâ'] = originalAddress; // CH·ªà hi·ªÉn th·ªã c√≥ d·∫•u
            }
            
            // 4. Chu·∫©n h√≥a s·ªë ƒëi·ªán tho·∫°i (kh√¥ng ·∫£nh h∆∞·ªüng b·ªüi d·∫•u)
            standardized['ƒêi·ªán tho·∫°i'] = extractAndNormalizePhone(rawDataOriginal);
            
            // 5. C√°c tr∆∞·ªùng kh√°c c≈©ng GI·ªÆ NGUY√äN c√≥ d·∫•u
            ['D√¢n t·ªôc', 'T√¥n gi√°o', 'Gi·ªõi t√≠nh', 'Email'].forEach(field => {
                if (standardized[field]) {
                    // Kh√¥ng thay ƒë·ªïi, gi·ªØ nguy√™n c√≥ d·∫•u
                }
            });
            
            return standardized;
        }

        function normalizeHeader(header) {
            if (!header) return '';
            
            const headerMap = {
                // H·ªç t√™n
                'h·ªç ƒë·ªám': 'H·ªç ƒë·ªám',
                'h·ªç': 'H·ªç',
                'ho': 'H·ªç',
                't√™n': 'T√™n',
                'ten': 'T√™n',
                'name': 'T√™n',
                'first name': 'T√™n',
                'last name': 'H·ªç',
                'h·ªç v√† t√™n': 'H·ªç v√† t√™n',
                'h·ªç t√™n': 'H·ªç v√† t√™n',
                'ho ten': 'H·ªç v√† t√™n',
                'fullname': 'H·ªç v√† t√™n',
                
                // Ng√†y sinh
                'ng√†y sinh': 'Ng√†y sinh',
                'ngay sinh': 'Ng√†y sinh',
                'ns': 'Ng√†y sinh',
                'birth date': 'Ng√†y sinh',
                'birth': 'Ng√†y sinh',
                'ng√†y': 'Ng√†y',
                'ngay': 'Ng√†y',
                'th√°ng': 'Th√°ng',
                'thang': 'Th√°ng',
                'nƒÉm sinh': 'NƒÉm sinh',
                'nam sinh': 'NƒÉm sinh',
                'nƒÉm': 'NƒÉm sinh',
                'nam': 'NƒÉm sinh',
                'year': 'NƒÉm sinh',
                
                // ƒê·ªãa ch·ªâ
                'ƒë·ªãa ch·ªâ': 'ƒê·ªãa ch·ªâ',
                'dia chi': 'ƒê·ªãa ch·ªâ',
                'dc': 'ƒê·ªãa ch·ªâ',
                'address': 'ƒê·ªãa ch·ªâ',
                's·ªë nh√†': 'S·ªë nh√†',
                'so nha': 'S·ªë nh√†',
                'ƒë∆∞·ªùng': 'ƒê∆∞·ªùng',
                'duong': 'ƒê∆∞·ªùng',
                'street': 'ƒê∆∞·ªùng',
                'khu ph·ªë': 'Khu ph·ªë',
                'khu pho': 'Khu ph·ªë',
                'kp': 'Khu ph·ªë',
                't·ªï d√¢n ph·ªë': 'T·ªï d√¢n ph·ªë',
                'to dan pho': 'T·ªï d√¢n ph·ªë',
                'tdp': 'T·ªï d√¢n ph·ªë',
                'ph∆∞·ªùng': 'Ph∆∞·ªùng',
                'phuong': 'Ph∆∞·ªùng',
                'ward': 'Ph∆∞·ªùng',
                'p.': 'Ph∆∞·ªùng',
                'qu·∫≠n': 'Qu·∫≠n',
                'quan': 'Qu·∫≠n',
                'district': 'Qu·∫≠n',
                'q.': 'Qu·∫≠n',
                'huy·ªán': 'Huy·ªán',
                'huyen': 'Huy·ªán',
                'h.': 'Huy·ªán',
                'th√†nh ph·ªë': 'Th√†nh ph·ªë',
                'thanh pho': 'Th√†nh ph·ªë',
                'tp': 'Th√†nh ph·ªë',
                'tp.': 'Th√†nh ph·ªë',
                'city': 'Th√†nh ph·ªë',
                't·ªânh': 'T·ªânh',
                'tinh': 'T·ªânh',
                'province': 'T·ªânh',
                
                // ƒêi·ªán tho·∫°i
                'ƒëi·ªán tho·∫°i': 'ƒêi·ªán tho·∫°i',
                'dien thoai': 'ƒêi·ªán tho·∫°i',
                'ƒët': 'ƒêi·ªán tho·∫°i',
                'dt': 'ƒêi·ªán tho·∫°i',
                'sƒët': 'ƒêi·ªán tho·∫°i',
                'sdt': 'ƒêi·ªán tho·∫°i',
                'phone': 'ƒêi·ªán tho·∫°i',
                'mobile': 'ƒêi·ªán tho·∫°i',
                'telephone': 'ƒêi·ªán tho·∫°i',
                
                // Kh√°c
                'd√¢n t·ªôc': 'D√¢n t·ªôc',
                'dan toc': 'D√¢n t·ªôc',
                't√¥n gi√°o': 'T√¥n gi√°o',
                'ton giao': 'T√¥n gi√°o',
                'gi·ªõi t√≠nh': 'Gi·ªõi t√≠nh',
                'gioi tinh': 'Gi·ªõi t√≠nh',
                'gt': 'Gi·ªõi t√≠nh',
                'gender': 'Gi·ªõi t√≠nh',
                'email': 'Email'
            };
            
            const normalized = header.toString().toLowerCase().trim()
                .replace(/[^\w\s√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/gi, '');
            
            return headerMap[normalized] || header;
        }

        function extractAndMergeFullName(data, row) {
            // T√¨m c√°c tr∆∞·ªùng c√≥ th·ªÉ ch·ª©a h·ªç v√† t√™n
            const nameFields = [];
            
            // T√¨m h·ªç, h·ªç ƒë·ªám, t√™n ri√™ng bi·ªát
            const ho = data['H·ªç'] || data['H·ªç ƒë·ªám'] || '';
            const ten = data['T√™n'] || '';
            
            if (ho && ten) {
                return `${ho} ${ten}`.trim();
            }
            
            // T√¨m tr∆∞·ªùng "H·ªç v√† t√™n" ho·∫∑c "H·ªç t√™n" c√≥ s·∫µn
            for (const [key, value] of Object.entries(data)) {
                const keyLower = key.toLowerCase();
                if ((keyLower.includes('h·ªç') && keyLower.includes('t√™n')) || 
                    keyLower.includes('fullname') || 
                    keyLower.includes('name')) {
                    if (value && value.length > 2) {
                        return value.trim();
                    }
                }
            }
            
            // T√¨m c√°c tr∆∞·ªùng c√≥ th·ªÉ ch·ª©a t√™n
            for (const [key, value] of Object.entries(data)) {
                const keyLower = key.toLowerCase();
                if ((keyLower.includes('h·ªç') || keyLower.includes('t√™n') || keyLower.includes('name')) && value) {
                    nameFields.push(value);
                }
            }
            
            // Gh√©p c√°c tr∆∞·ªùng t√™n l·∫°i
            if (nameFields.length > 0) {
                return nameFields.join(' ').trim();
            }
            
            return ho || ten || '';
        }

        function extractAndNormalizeBirthDate(data, row) {
            // T√¨m ng√†y sinh t·ª´ c√°c tr∆∞·ªùng ri√™ng bi·ªát
            const ngay = data['Ng√†y'] || '';
            const thang = data['Th√°ng'] || '';
            const nam = data['NƒÉm sinh'] || data['NƒÉm'] || '';
            
            if (ngay && thang && nam) {
                const combined = `${ngay}/${thang}/${nam}`;
                return normalizeBirthDate(combined);
            }
            
            // T√¨m trong tr∆∞·ªùng ng√†y sinh c√≥ s·∫µn
            for (const [key, value] of Object.entries(data)) {
                const keyLower = key.toLowerCase();
                if ((keyLower.includes('sinh') || keyLower.includes('birth')) && value) {
                    return normalizeBirthDate(value);
                }
            }
            
            // T√¨m trong t·∫•t c·∫£ c√°c tr∆∞·ªùng c√≥ th·ªÉ ch·ª©a ng√†y
            for (const [key, value] of Object.entries(data)) {
                if (value && typeof value === 'string') {
                    // Ki·ªÉm tra pattern ng√†y
                    if (/\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{4}/.test(value) || /^\d{8}$/.test(value)) {
                        const normalized = normalizeBirthDate(value);
                        if (normalized && normalized !== value) {
                            return normalized;
                        }
                    }
                }
            }
            
            return '';
        }

        function extractAndMergeAddress(data) {
            const addressParts = [];
            
            // Th·ª© t·ª± ∆∞u ti√™n cho ƒë·ªãa ch·ªâ Vi·ªát Nam
            const addressOrder = [
                'S·ªë nh√†', 'ƒê∆∞·ªùng', 'Khu ph·ªë', 'T·ªï d√¢n ph·ªë', 
                'Ph∆∞·ªùng', 'Qu·∫≠n', 'Huy·ªán', 'Th√†nh ph·ªë', 'T·ªânh'
            ];
            
            // Thu th·∫≠p c√°c ph·∫ßn ƒë·ªãa ch·ªâ theo th·ª© t·ª±
            addressOrder.forEach(field => {
                if (data[field] && data[field].trim()) {
                    addressParts.push(data[field].trim());
                }
            });
            
            // N·∫øu ƒë√£ c√≥ tr∆∞·ªùng ƒë·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß
            if (data['ƒê·ªãa ch·ªâ'] && data['ƒê·ªãa ch·ªâ'].trim()) {
                const existingAddress = normalizeAddress(data['ƒê·ªãa ch·ªâ']);
                if (addressParts.length > 0) {
                    // K·∫øt h·ª£p ƒë·ªãa ch·ªâ c√≥ s·∫µn v·ªõi c√°c ph·∫ßn b·ªï sung
                    return `${existingAddress}, ${addressParts.join(', ')}`;
                }
                return existingAddress;
            }
            
            // Gh√©p c√°c ph·∫ßn ƒë·ªãa ch·ªâ
            if (addressParts.length > 0) {
                return normalizeAddress(addressParts.join(', '));
            }
            
            return '';
        }

        function extractAndNormalizePhone(data) {
            let phone = '';
            
            // T√¨m s·ªë ƒëi·ªán tho·∫°i t·ª´ c√°c tr∆∞·ªùng c√≥ th·ªÉ
            for (const [key, value] of Object.entries(data)) {
                const keyLower = key.toLowerCase();
                if ((keyLower.includes('ƒëi·ªán tho·∫°i') || 
                     keyLower.includes('phone') ||
                     keyLower.includes('mobile') ||
                     keyLower.includes('sƒët') ||
                     keyLower.includes('ƒët')) && value) {
                    phone = value;
                    break;
                }
            }
            
            // N·∫øu kh√¥ng t√¨m th·∫•y, ki·ªÉm tra t·∫•t c·∫£ tr∆∞·ªùng c√≥ ƒë·ªãnh d·∫°ng s·ªë ƒëi·ªán tho·∫°i
            if (!phone) {
                for (const [key, value] of Object.entries(data)) {
                    if (value && /^[\d\+\-\s\(\)\.]{8,15}$/.test(value.toString().trim())) {
                        phone = value;
                        break;
                    }
                }
            }
            
            return normalizePhoneNumber(phone);
        }

        function normalizeAddress(address) {
            if (!address) return '';
            
            let normalized = address.toString().trim();
            
            // Chu·∫©n h√≥a c√°c t·ª´ vi·∫øt t·∫Øt
            const replacements = {
                'P\\.\\s*': 'Ph∆∞·ªùng ',
                'Q\\.\\s*': 'Qu·∫≠n ',
                'H\\.\\s*': 'Huy·ªán ',
                'TP\\.\\s*': 'Th√†nh ph·ªë ',
                'TT\\.\\s*': 'Th·ªã tr·∫•n ',
                '\\bKP\\b': 'Khu ph·ªë',
                '\\bTDP\\b': 'T·ªï d√¢n ph·ªë',
                '\\bTX\\b': 'Th·ªã x√£',
                '\\bTT\\b': 'Th·ªã tr·∫•n'
            };
            
            for (const [pattern, replacement] of Object.entries(replacements)) {
                normalized = normalized.replace(new RegExp(pattern, 'gi'), replacement);
            }
            
            // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a v√† d·∫•u ph·∫©y th·ª´a
            normalized = normalized.replace(/\s+/g, ' ')
                                   .replace(/,\s*,/g, ',')
                                   .replace(/,\s*$/, '')
                                   .replace(/^\s*,/, '')
                                   .trim();
            
            return normalized;
        }

        function normalizePhoneNumber(phone) {
            if (!phone) return '';
            
            let normalized = phone.toString().trim();
            
            // Lo·∫°i b·ªè k√Ω t·ª± kh√¥ng ph·∫£i s·ªë
            normalized = normalized.replace(/[^\d]/g, '');
            
            // Chu·∫©n h√≥a s·ªë ƒëi·ªán tho·∫°i Vi·ªát Nam
            if (normalized.length >= 9) {
                // X·ª≠ l√Ω m√£ v√πng +84
                if (normalized.startsWith('84') && normalized.length >= 10) {
                    normalized = '0' + normalized.slice(2);
                }
                // T·ª± ƒë·ªông th√™m s·ªë 0 n·∫øu ch∆∞a c√≥ v√† ƒë·ªß 9 ch·ªØ s·ªë
                else if (!normalized.startsWith('0') && normalized.length === 9) {
                    normalized = '0' + normalized;
                }
                // T·ª± ƒë·ªông th√™m s·ªë 0 n·∫øu ch∆∞a c√≥ v√† c√≥ 10 ch·ªØ s·ªë (tr∆∞·ªùng h·ª£p b·ªè s·ªë 0 ƒë·∫ßu)
                else if (!normalized.startsWith('0') && normalized.length === 10) {
                    // Ki·ªÉm tra xem c√≥ ph·∫£i s·ªë VN kh√¥ng (b·∫Øt ƒë·∫ßu b·∫±ng 3,5,7,8,9)
                    if (/^[35789]/.test(normalized)) {
                        normalized = '0' + normalized;
                    }
                }
            }
            
            return normalized;
        }

        function isValidPhoneNumber(phone) {
            if (!phone) return false;
            
            // S·ªë ƒëi·ªán tho·∫°i VN h·ª£p l·ªá: 10-11 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 0
            const phoneRegex = /^0[35789]\d{8,9}$/;
            return phoneRegex.test(phone);
        }

        function validateData(data) {
            const results = {
                totalRecords: data.length,
                validNames: 0,
                validDates: 0,
                validAddresses: 0,
                validPhones: 0,
                recordsWithPhone: 0,
                issues: []
            };
            
            data.forEach((row, index) => {
                let issuesInRow = [];
                
                // Validate h·ªç t√™n
                if (row['H·ªç v√† t√™n'] && row['H·ªç v√† t√™n'].length >= 3) {
                    // Ki·ªÉm tra c√≥ √≠t nh·∫•t 2 t·ª´ (h·ªç + t√™n)
                    const nameParts = row['H·ªç v√† t√™n'].trim().split(/\s+/);
                    if (nameParts.length >= 2) {
                        results.validNames++;
                    } else {
                        issuesInRow.push('H·ªç t√™n ch∆∞a ƒë·∫ßy ƒë·ªß');
                    }
                } else {
                    issuesInRow.push('H·ªç t√™n kh√¥ng h·ª£p l·ªá ho·∫∑c qu√° ng·∫Øn');
                }
                
                // Validate ng√†y sinh
                if (row['Ng√†y sinh']) {
                    if (/^\d{2}\/\d{2}\/\d{4}$/.test(row['Ng√†y sinh'])) {
                        const [day, month, year] = row['Ng√†y sinh'].split('/').map(Number);
                        if (isValidDate(day.toString().padStart(2, '0'), 
                                       month.toString().padStart(2, '0'), 
                                       year.toString())) {
                            results.validDates++;
                        } else {
                            issuesInRow.push('Ng√†y sinh kh√¥ng h·ª£p l·ªá (ng√†y/th√°ng sai)');
                        }
                    } else {
                        issuesInRow.push('Format ng√†y sinh kh√¥ng ƒë√∫ng (c·∫ßn DD/MM/YYYY)');
                    }
                }
                
                // Validate ƒë·ªãa ch·ªâ
                if (row['ƒê·ªãa ch·ªâ'] && row['ƒê·ªãa ch·ªâ'].length >= 15) {
                    results.validAddresses++;
                } else if (row['ƒê·ªãa ch·ªâ']) {
                    issuesInRow.push('ƒê·ªãa ch·ªâ qu√° ng·∫Øn ho·∫∑c ch∆∞a ƒë·∫ßy ƒë·ªß');
                }
                
                // Validate s·ªë ƒëi·ªán tho·∫°i
                if (row['ƒêi·ªán tho·∫°i']) {
                    results.recordsWithPhone++;
                    if (isValidPhoneNumber(row['ƒêi·ªán tho·∫°i'])) {
                        results.validPhones++;
                    } else {
                        issuesInRow.push('S·ªë ƒëi·ªán tho·∫°i kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng VN');
                    }
                }
                
                // Th√™m v√†o danh s√°ch l·ªói n·∫øu c√≥
                if (issuesInRow.length > 0) {
                    results.issues.push(`H√†ng ${index + 1}: ${issuesInRow.join(', ')}`);
                }
            });
            
            return results;
        }

        function displayResults(data) {
            // Hi·ªÉn th·ªã th·ªëng k√™
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${data.length}</div>
                    <div class="stat-label">T·ªïng b·∫£n ghi h·ª£p l·ªá</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${processingStats.totalFiles}</div>
                    <div class="stat-label">File ƒë√£ x·ª≠ l√Ω</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${processingStats.totalSheets}</div>
                    <div class="stat-label">Sheet ƒë√£ qu√©t</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${validationResults.validNames}</div>
                    <div class="stat-label">H·ªç t√™n h·ª£p l·ªá</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${validationResults.validDates}</div>
                    <div class="stat-label">Ng√†y sinh h·ª£p l·ªá</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${validationResults.validPhones}</div>
                    <div class="stat-label">SƒêT h·ª£p l·ªá</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${validationResults.recordsWithPhone}</div>
                    <div class="stat-label">C√≥ s·ªë ƒëi·ªán tho·∫°i</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${validationResults.validAddresses}</div>
                    <div class="stat-label">ƒê·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß</div>
                </div>
            `;
            
            // Hi·ªÉn th·ªã validation results
            const validationDiv = document.getElementById('validationResults');
            const issuesCount = validationResults.issues.length;
            
            let validationHTML = `
                <div class="validation-pass">‚úÖ ƒê√£ x·ª≠ l√Ω ${data.length} b·∫£n ghi t·ª´ ${processingStats.totalFiles} file</div>
                <div class="validation-pass">‚úÖ Qu√©t ${processingStats.totalSheets} sheet, lo·∫°i b·ªè d√≤ng tr·ªëng t·ª± ƒë·ªông</div>
            `;
            
            if (getProcessingOptions().requirePhoneNumber) {
                validationHTML += `<div class="validation-pass">‚úÖ Ch·ªâ gi·ªØ l·∫°i ${validationResults.recordsWithPhone} d√≤ng c√≥ s·ªë ƒëi·ªán tho·∫°i</div>`;
            }
            
            if (issuesCount === 0) {
                validationHTML += '<div class="validation-pass">‚úÖ T·∫•t c·∫£ d·ªØ li·ªáu ƒë·ªÅu ƒë·∫°t ch·∫•t l∆∞·ª£ng t·ªët!</div>';
            } else {
                validationHTML += `
                    <div class="validation-warning">‚ö†Ô∏è Ph√°t hi·ªán ${issuesCount} v·∫•n ƒë·ªÅ c·∫ßn l∆∞u √Ω:</div>
                    ${validationResults.issues.slice(0, 15).map(issue => 
                        `<div class="validation-item validation-error">‚Ä¢ ${issue}</div>`
                    ).join('')}
                    ${issuesCount > 15 ? `<div class="validation-item">... v√† ${issuesCount - 15} v·∫•n ƒë·ªÅ kh√°c (xem trong b√°o c√°o chi ti·∫øt)</div>` : ''}
                `;
            }
            
            validationDiv.innerHTML = validationHTML;
            
            // Hi·ªÉn th·ªã preview
            displayPreview(data);
            
            // Enable buttons
            document.getElementById('downloadBtn').disabled = false;
            document.getElementById('reportBtn').disabled = false;
            
            // Show results
            document.getElementById('analysisResults').classList.add('show');
            
            showSuccess(`üéâ X·ª≠ l√Ω ho√†n t·∫•t! ${data.length} b·∫£n ghi h·ª£p l·ªá t·ª´ ${processingStats.totalFiles} file Excel`);
        }

        function displayPreview(data) {
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('tableBody');
            const previewCount = document.getElementById('previewCount');
            
            if (data.length === 0) {
                previewCount.textContent = 'Kh√¥ng c√≥ d·ªØ li·ªáu';
                return;
            }
            
            const displayCount = Math.min(20, data.length);
            previewCount.textContent = `Hi·ªÉn th·ªã ${displayCount}/${data.length} b·∫£n ghi`;
            
            // Create header
            const headers = Object.keys(data[0]);
            tableHeader.innerHTML = '';
            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                th.title = header;
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);
            
            // Create body
            tableBody.innerHTML = '';
            
            for (let i = 0; i < displayCount; i++) {
                const row = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    const value = data[i][header] || '';
                    td.textContent = value;
                    td.title = value;
                    row.appendChild(td);
                });
                tableBody.appendChild(row);
            }
        }

        function downloadProcessedFile() {
            if (processedData.length === 0) {
                showError('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ t·∫£i xu·ªëng');
                return;
            }
            
            try {
                const wb = XLSX.utils.book_new();
                
                // T·∫°o d·ªØ li·ªáu ch√≠nh v·ªõi ti·∫øng Vi·ªát c√≥ d·∫•u (lo·∫°i b·ªè c·ªôt kh√¥ng d·∫•u)
                const vietnameseData = processedData.map(row => {
                    const cleanRow = {};
                    
                    // Ch·ªâ gi·ªØ l·∫°i c√°c c·ªôt ch√≠nh v·ªõi ti·∫øng Vi·ªát c√≥ d·∫•u
                    Object.keys(row).forEach(key => {
                        // Lo·∫°i b·ªè t·∫•t c·∫£ c·ªôt c√≥ "(kh√¥ng d·∫•u)"
                        if (!key.includes('(kh√¥ng d·∫•u)')) {
                            cleanRow[key] = row[key];
                        }
                    });
                    
                    return cleanRow;
                });
                
                // T·∫°o sheet ch√≠nh v·ªõi d·ªØ li·ªáu ti·∫øng Vi·ªát
                const ws = XLSX.utils.json_to_sheet(vietnameseData);
                
                // Th√™m auto filter v√† formatting
                ws['!autofilter'] = { ref: XLSX.utils.encode_range(XLSX.utils.decode_range(ws['!ref'])) };
                
                // Set column widths t·ªëi ∆∞u
                const colWidths = [
                    { wch: 5 },   // STT
                    { wch: 25 },  // H·ªç v√† t√™n
                    { wch: 12 },  // Ng√†y sinh
                    { wch: 45 },  // ƒê·ªãa ch·ªâ
                    { wch: 12 },  // ƒêi·ªán tho·∫°i
                    { wch: 15 },  // D√¢n t·ªôc
                    { wch: 15 },  // T√¥n gi√°o
                    { wch: 10 },  // Gi·ªõi t√≠nh
                    { wch: 15 },  // Email
                    { wch: 35 }   // SheetSource
                ];
                ws['!cols'] = colWidths;
                
                // Th√™m styling cho header (m√†u xanh ƒë·∫πp)
                const range = XLSX.utils.decode_range(ws['!ref']);
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const headerCell = XLSX.utils.encode_cell({ r: 0, c: col });
                    if (ws[headerCell]) {
                        ws[headerCell].s = {
                            font: { bold: true, color: { rgb: "FFFFFF" }, size: 12 },
                            fill: { fgColor: { rgb: "2E75B6" } },
                            alignment: { horizontal: "center", vertical: "center" },
                            border: {
                                top: { style: "thin", color: { rgb: "000000" } },
                                bottom: { style: "thin", color: { rgb: "000000" } },
                                left: { style: "thin", color: { rgb: "000000" } },
                                right: { style: "thin", color: { rgb: "000000" } }
                            }
                        };
                    }
                }
                
                // Styling cho d·ªØ li·ªáu (alternating rows)
                for (let row = 1; row <= range.e.r; row++) {
                    for (let col = range.s.c; col <= range.e.c; col++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                        if (ws[cellAddress]) {
                            ws[cellAddress].s = {
                                alignment: { vertical: "center", wrapText: true },
                                fill: { fgColor: { rgb: row % 2 === 0 ? "F2F2F2" : "FFFFFF" } },
                                border: {
                                    top: { style: "thin", color: { rgb: "E0E0E0" } },
                                    bottom: { style: "thin", color: { rgb: "E0E0E0" } },
                                    left: { style: "thin", color: { rgb: "E0E0E0" } },
                                    right: { style: "thin", color: { rgb: "E0E0E0" } }
                                }
                            };
                        }
                    }
                }
                
                XLSX.utils.book_append_sheet(wb, ws, "D·ªØ li·ªáu ti·∫øng Vi·ªát");
                
                // T·∫°o sheet th·ªëng k√™ v·ªõi ti·∫øng Vi·ªát
                const statsSheet = createVietnameseStatsSheet();
                XLSX.utils.book_append_sheet(wb, statsSheet, "Th·ªëng k√™");
                
                // T·∫°o sheet kh√¥ng d·∫•u (cho h·ªá th·ªëng) n·∫øu c·∫ßn
                const normalizedSheet = createSystemFriendlySheet();
                XLSX.utils.book_append_sheet(wb, normalizedSheet, "D·ªØ li·ªáu h·ªá th·ªëng");
                
                const fileName = `DuLieu_TiengViet_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.xlsx`;
                XLSX.writeFile(wb, fileName);
                
                showSuccess(`üì• ƒê√£ t·∫£i xu·ªëng: ${fileName} - D·ªØ li·ªáu ti·∫øng Vi·ªát c√≥ d·∫•u ho√†n ch·ªânh (3 sheets)`);
            } catch (error) {
                showError(`L·ªói t·∫£i xu·ªëng: ${error.message}`);
            }
        }

        function createVietnameseStatsSheet() {
            const stats = [
                ['üìä TH·ªêNG K√ä X·ª¨ L√ù D·ªÆ LI·ªÜU TI·∫æNG VI·ªÜT', ''],
                ['Th·ªùi gian x·ª≠ l√Ω:', new Date().toLocaleString('vi-VN')],
                ['', ''],
                ['üè¢ T·ªîNG QUAN D·ª∞ √ÅN', ''],
                ['S·ªë file Excel ƒë√£ x·ª≠ l√Ω:', processingStats.totalFiles || 0],
                ['T·ªïng s·ªë sheet ƒë√£ qu√©t:', processingStats.totalSheets || 0],
                ['T·ªïng b·∫£n ghi h·ª£p l·ªá:', validationResults.totalRecords || 0],
                ['C√°c file c√≥ d·ªØ li·ªáu:', processingStats.filesWithData || 0],
                ['', ''],
                ['‚úÖ CH·∫§T L∆Ø·ª¢NG D·ªÆ LI·ªÜU', ''],
                ['H·ªç t√™n ƒë·∫ßy ƒë·ªß v√† h·ª£p l·ªá:', validationResults.validNames || 0],
                ['Ng√†y sinh ƒë√∫ng ƒë·ªãnh d·∫°ng:', validationResults.validDates || 0],
                ['ƒê·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß v√† chi ti·∫øt:', validationResults.validAddresses || 0],
                ['S·ªë ƒëi·ªán tho·∫°i chu·∫©n Vi·ªát Nam:', validationResults.validPhones || 0],
                ['B·∫£n ghi c√≥ s·ªë ƒëi·ªán tho·∫°i:', validationResults.recordsWithPhone || 0],
                ['', ''],
                ['‚öôÔ∏è C·∫§U H√åNH X·ª¨ L√ù ƒê√É √ÅP D·ª§NG', ''],
                ['Hi·ªÉn th·ªã ti·∫øng Vi·ªát c√≥ d·∫•u:', 'C√≥ (Nguy·ªÖn VƒÉn An, H√† N·ªôi...)'],
                ['Chu·∫©n h√≥a ng√†y sinh YYYYMMDD ‚Üí DD/MM/YYYY:', getProcessingOptions().normalizeDate ? 'C√≥' : 'Kh√¥ng'],
                ['T·ª± ƒë·ªông gh√©p h·ªç + t√™n:', getProcessingOptions().mergeNameFields ? 'C√≥' : 'Kh√¥ng'],
                ['T·ª± ƒë·ªông gh√©p ƒë·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß:', getProcessingOptions().mergeAddressFields ? 'C√≥' : 'Kh√¥ng'],
                ['Ch·ªâ gi·ªØ b·∫£n ghi c√≥ s·ªë ƒëi·ªán tho·∫°i:', getProcessingOptions().requirePhoneNumber ? 'C√≥' : 'Kh√¥ng'],
                ['T·ª± ƒë·ªông th√™m s·ªë 0 cho SƒêT:', 'C√≥ (912345678 ‚Üí 0912345678)'],
                ['', ''],
                ['üéØ K·∫æT QU·∫¢ CU·ªêI C√ôNG', ''],
                ['T·ª∑ l·ªá d·ªØ li·ªáu h·ª£p l·ªá:', `${Math.round((validationResults.validNames / validationResults.totalRecords) * 100)}%`],
                ['T·ª∑ l·ªá c√≥ s·ªë ƒëi·ªán tho·∫°i:', `${Math.round((validationResults.recordsWithPhone / validationResults.totalRecords) * 100)}%`],
                ['ƒê·ªãnh d·∫°ng xu·∫•t ra:', 'Ti·∫øng Vi·ªát c√≥ d·∫•u (UTF-8)'],
                ['T∆∞∆°ng th√≠ch v·ªõi:', 'Excel, Google Sheets, LibreOffice'],
                ['', ''],
                ['üìù GHI CH√ö', ''],
                ['Sheet "D·ªØ li·ªáu ti·∫øng Vi·ªát":', 'D·ªØ li·ªáu ch√≠nh v·ªõi ti·∫øng Vi·ªát ƒë·∫ßy ƒë·ªß'],
                ['Sheet "D·ªØ li·ªáu h·ªá th·ªëng":', 'D·ªØ li·ªáu kh√¥ng d·∫•u cho l·∫≠p tr√¨nh'],
                ['Encoding:', 'UTF-8 v·ªõi BOM ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng ti·∫øng Vi·ªát']
            ];
            
            return XLSX.utils.aoa_to_sheet(stats);
        }

        function createSystemFriendlySheet() {
            // T·∫°o sheet kh√¥ng d·∫•u cho h·ªá th·ªëng (database, API...)
            return processedData.map(row => {
                const systemRow = {
                    'stt': row['STT'],
                    'ho_va_ten': removeVietnameseTones(row['H·ªç v√† t√™n'] || ''),
                    'ngay_sinh': row['Ng√†y sinh'] || '',
                    'dia_chi': removeVietnameseTones(row['ƒê·ªãa ch·ªâ'] || ''),
                    'dien_thoai': row['ƒêi·ªán tho·∫°i'] || '',
                    'dan_toc': removeVietnameseTones(row['D√¢n t·ªôc'] || ''),
                    'ton_giao': removeVietnameseTones(row['T√¥n gi√°o'] || ''),
                    'gioi_tinh': row['Gi·ªõi t√≠nh'] || '',
                    'email': row['Email'] || '',
                    'nguon_du_lieu': removeVietnameseTones(row['SheetSource'] || '')
                };
                
                return systemRow;
            });
        }

        function createStatsSheet() {
            const stats = [
                ['TH·ªêNG K√ä X·ª¨ L√ù D·ªÆ LI·ªÜU', ''],
                ['Th·ªùi gian x·ª≠ l√Ω:', new Date().toLocaleString('vi-VN')],
                ['', ''],
                ['T·ªîNG QUAN', ''],
                ['S·ªë file ƒë√£ x·ª≠ l√Ω:', processingStats.totalFiles],
                ['T·ªïng sheet ƒë√£ qu√©t:', processingStats.totalSheets],
                ['T·ªïng b·∫£n ghi h·ª£p l·ªá:', validationResults.totalRecords],
                ['', ''],
                ['CH·∫§T L∆Ø·ª¢NG D·ªÆ LI·ªÜU', ''],
                ['H·ªç t√™n h·ª£p l·ªá:', validationResults.validNames],
                ['Ng√†y sinh h·ª£p l·ªá:', validationResults.validDates],
                ['ƒê·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß:', validationResults.validAddresses],
                ['S·ªë ƒëi·ªán tho·∫°i h·ª£p l·ªá:', validationResults.validPhones],
                ['B·∫£n ghi c√≥ SƒêT:', validationResults.recordsWithPhone],
                ['', ''],
                ['T√ôY CH·ªåN ƒê√É √ÅPD·ª§NG', ''],
                ['Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát:', getProcessingOptions().removeVietnameseTones ? 'C√≥' : 'Kh√¥ng'],
                ['Chu·∫©n h√≥a ng√†y sinh:', getProcessingOptions().normalizeDate ? 'C√≥' : 'Kh√¥ng'],
                ['Gh√©p h·ªç + t√™n:', getProcessingOptions().mergeNameFields ? 'C√≥' : 'Kh√¥ng'],
                ['Gh√©p ƒë·ªãa ch·ªâ:', getProcessingOptions().mergeAddressFields ? 'C√≥' : 'Kh√¥ng'],
                ['Ch·ªâ gi·ªØ d√≤ng c√≥ SƒêT:', getProcessingOptions().requirePhoneNumber ? 'C√≥' : 'Kh√¥ng']
            ];
            
            return XLSX.utils.aoa_to_sheet(stats);
        }

        function downloadReport() {
            const report = {
                'Th·ªùi gian': new Date().toLocaleString('vi-VN'),
                'T·ªïng file': processingStats.totalFiles,
                'T·ªïng sheet': processingStats.totalSheets,
                'T·ªïng b·∫£n ghi': validationResults.totalRecords,
                'H·ªç t√™n h·ª£p l·ªá': validationResults.validNames,
                'Ng√†y sinh h·ª£p l·ªá': validationResults.validDates,
                'ƒê·ªãa ch·ªâ h·ª£p l·ªá': validationResults.validAddresses,
                'SƒêT h·ª£p l·ªá': validationResults.validPhones,
                'C√≥ SƒêT': validationResults.recordsWithPhone,
                'S·ªë v·∫•n ƒë·ªÅ': validationResults.issues.length
            };
            
            const wb = XLSX.utils.book_new();
            
            // Sheet b√°o c√°o t·ªïng quan
            const reportWs = XLSX.utils.json_to_sheet([report]);
            XLSX.utils.book_append_sheet(wb, reportWs, "BaoCao_TongQuan");
            
            // Sheet danh s√°ch l·ªói chi ti·∫øt
            if (validationResults.issues.length > 0) {
                const issuesData = validationResults.issues.map((issue, index) => ({
                    'STT': index + 1,
                    'V·∫•n ƒë·ªÅ': issue
                }));
                const issuesWs = XLSX.utils.json_to_sheet(issuesData);
                XLSX.utils.book_append_sheet(wb, issuesWs, "DanhSach_VanDe");
            }
            
            // Sheet c·∫•u h√¨nh x·ª≠ l√Ω
            const configData = [
                { 'T√πy ch·ªçn': 'Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát', 'Gi√° tr·ªã': getProcessingOptions().removeVietnameseTones ? 'C√≥' : 'Kh√¥ng' },
                { 'T√πy ch·ªçn': 'Chu·∫©n h√≥a ng√†y sinh', 'Gi√° tr·ªã': getProcessingOptions().normalizeDate ? 'C√≥' : 'Kh√¥ng' },
                { 'T√πy ch·ªçn': 'Gh√©p h·ªç + t√™n', 'Gi√° tr·ªã': getProcessingOptions().mergeNameFields ? 'C√≥' : 'Kh√¥ng' },
                { 'T√πy ch·ªçn': 'Gh√©p ƒë·ªãa ch·ªâ', 'Gi√° tr·ªã': getProcessingOptions().mergeAddressFields ? 'C√≥' : 'Kh√¥ng' },
                { 'T√πy ch·ªçn': 'Ch·ªâ gi·ªØ d√≤ng c√≥ SƒêT', 'Gi√° tr·ªã': getProcessingOptions().requirePhoneNumber ? 'C√≥' : 'Kh√¥ng' }
            ];
            const configWs = XLSX.utils.json_to_sheet(configData);
            XLSX.utils.book_append_sheet(wb, configWs, "CauHinh_XuLy");
            
            const fileName = `BaoCao_XuLyDuLieu_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.xlsx`;
            XLSX.writeFile(wb, fileName);
            
            showSuccess(`üìä ƒê√£ t·∫£i b√°o c√°o: ${fileName}`);
        }

        function resetProcessor() {
            selectedFiles = [];
            processedData = [];
            originalData = [];
            processingStats = {};
            validationResults = {};
            fileProgress = {};
            
            document.getElementById('analysisResults').classList.remove('show');
            document.getElementById('fileInput').value = '';
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('reportBtn').disabled = true;
            
            updateFileList();
            clearStatus();
        }

        function showProgress(show) {
            document.getElementById('progressSection').classList.toggle('show', show);
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        function showSuccess(message) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-success">${message}</div>`;
            setTimeout(() => clearStatus(), 5000);
        }

        function showError(message) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-error">${message}</div>`;
            setTimeout(() => clearStatus(), 8000);
        }

        function showWarning(message) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-info">${message}</div>`;
            setTimeout(() => clearStatus(), 6000);
        }

        function showInfo(message) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-info">${message}</div>`;
            setTimeout(() => clearStatus(), 5000);
        }

        function clearStatus() {
            document.getElementById('statusMessage').innerHTML = '';
        }

        // Kh·ªüi t·∫°o giao di·ªán
        document.addEventListener('DOMContentLoaded', function() {
            // Set default options
            document.getElementById('removeVietnameseTones').checked = true;
            document.getElementById('normalizeDate').checked = true;
            document.getElementById('mergeNameFields').checked = true;
            document.getElementById('mergeAddressFields').checked = true;
            document.getElementById('requirePhoneNumber').checked = true;
            
            showInfo('üöÄ H·ªá th·ªëng ƒë√£ s·∫µn s√†ng! H·ªó tr·ª£ x·ª≠ l√Ω kh√¥ng gi·ªõi h·∫°n file Excel v·ªõi AI th√¥ng minh.');
        });
    </script>
</body>  
</html>
